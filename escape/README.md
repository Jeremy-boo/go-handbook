## Golang 逃逸分析初探> 逃逸分析是编译器决定变量是分配在堆上还是分配在栈上的一种行为> Attention: Go语言实在编译阶段确定逃逸的，并不是在运行时### 1. 逃逸分析的基本概念> 1.1 堆与栈的区别- Heap(堆)：用来存较大的对象，手动分配申请，分配和释放内存，分配速度较慢- Stack(栈)：由编译器管理，自动申请、分配和释放；一般局部变量和函数参数都会放在栈上。> 1.2 判断逃逸分析的规则：-  变量是否在其他地方被引用(非局部)，只要可能被引用，他一定分配到堆上，否则分配在栈上-  对象过大也有可能被分配在栈上> 1.3 能引起逃逸分析的典型情况：- 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。- 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。    所以编译器没法知道变量什么时候才会被释放。- 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。    尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，    它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。- 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。    想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。    > 1.4 如何判断逃逸分析1.4.1 通过编译器提供的命令-gcflags可以查看详细的逃逸分析过程     go build -gcflags=-m -l main.go2.通过反编译命令查看    go tool compile -S main.go > 1.5 如何避免逃逸分析 https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ### 2.